<!DOCTYPE html>
<html lang="en">

<head>
	<title>Bloch Sphere Simulation</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/aa3421/cm-web-fonts/fonts.css">
	  <link rel="icon" href="../images/state0.png">
	
	<style>
		body {
			margin: 0;
			overflow: hidden;
			font-family: "Computer Modern Serif", serif;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

		#state0 {
			position: absolute;
			top: 17px;
			left: 100px;
			font-size: 150%;
			color: white;
			background-color: rgba(0, 0, 0, 0.5);
			padding: 10px;
			border-radius: 5px;
		}		
		
		#state1 {
			position: absolute;
			top: 17px;
			left: 215px;
			font-size: 150%;
			color: white;
			background-color: rgba(0, 0, 0, 0.5);
			padding: 10px;
			border-radius: 5px;
		}
		#command_box {
			position: absolute;
			top: 72%;
			color: white;
			background-color: rgba(0, 0, 0, 0.5);
			padding: 10px;
			border-radius: 5px;
			height: 80px;
			width: 80px;
			margin-left: 10px;
		}

		#eqStart {
			position: absolute;
			top: 25px;
			left: 20px;
			height: 32px;
			width: 80px;
		}

		#plus {
			position: absolute;
			top: 34px;
			left: 200px;
			height: 16px;
			width: 16px;		
		}

		#zeroIcon {
			position: absolute;
			top: 27px;
			left: 160px;
			height: 30px;
			width: 30px;
		}

		#oneIcon {
			position: absolute;
			top: 27px;
			left: 275px;
			height: 30px;
			width: 30px;
		}

		#commands {
			height: 20px;
			width: 150px;
			margin-bottom: 10px;
		}

		#commandH {
			height: 20px;
			width: 180px;
			margin-bottom: 10px;
		}

		#command0 {
			height: 22px;
			width: 100px;
			margin-bottom: 10px;		
		}

		#commandR {
			height: 22px;
			width: 170px;		
		}
	</style>
</head>

<body>
	<img src="../images/psi.png" id="eqStart">
	<div id="state0"></div>
	<img src="../images/state0.png" id="zeroIcon">
	<img src="../images/plus.png" id="plus">
	<div id="state1"></div>
	<img src="../images/state1.png" id="oneIcon">
	<div id="command_box">
		<img src="../images/X_gate.png" id="commands">
		<img src="../images/Y_gate.png" id="commands">
		<img src="../images/Z_gate.png" id="commands">
		<img src="../images/H_gate.png" id="commandH">
		<img src="../images/0StateCommand.png" id="command0">
		<img src="../images/resetCommand.png" id="commandR">
	</div>
	<script src="three-r134.js"></script>
	<script>
		"use strict"; // https://stackoverflow.com/q/1335851/72470

		// Global variables that are available in all functions.
		// Note: You can add your own here, e.g. to store the rendering mode.
		var camera, 
		scene, 
		renderer,
		arrowHelper, 
		probState0, 
		probState1, 
		sphereGroup, 
		pos, 
		neg ,
		pos_i, 
		neg_i,
		state0,
		state1,
		torusX,
		torusY,
		torusZ,
		dirNew,
		X,
		Y,
		Z,
		finalProbState0,
		finalProbState1,
		startProbState0,
		startProbState1
		let cameraAngle = 0;
		const distFromOrigin = 10;
		const sphereRadius = 2;
		let stepQuat = null;
		let rotatedAngle = 0;
		let rotationAxis = null;
		let finalAngle = 0;

		do {
			X = Math.random() * 2 - 1;
			Y = Math.random() * 2 - 1;
			Z = Math.random() * 2 - 1;
		} while (X === 0 && Y === 0 && Z === 0);

		// Initialise the scene, and draw it for the first time.
		init();
		animate();

		// Listen for keyboard events, to react to them.
		// Note: there are also other event listeners, e.g. for mouse events.
		document.addEventListener('keydown', handleKeyDown);

		// Scene initialisation. This function is only run once, at the very beginning.
		function init() {
			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(3, 3, 3);
			camera.lookAt(new THREE.Vector3(0, 0, 0));


			// TASK: Draw a cube (requirement 0).
			const geometry = new THREE.TorusGeometry( sphereRadius, 0.01, 16, 100 ); 
			const material = new THREE.MeshBasicMaterial( { color: 0xffffff , } ); 
			torusX = new THREE.Mesh( geometry, material ); 
			scene.add( torusX );
			torusX.rotation.x = Math.PI / 2;

			torusY = new THREE.Mesh( geometry, material ); 
			scene.add( torusY );
			torusY.rotation.y = Math.PI / 2;
			
			torusZ = new THREE.Mesh( geometry, material ); 
			scene.add( torusZ );

			sphereGroup = new THREE.Group();

			// Add your Bloch sphere mesh
			const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
			const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x8888ff, wireframe: true });
			const blochSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
			blochSphere.visible = false;
			sphereGroup.add(blochSphere);
			

			scene.add(sphereGroup);

			let dir = new THREE.Vector3( X, Y, Z );
			//normalize the direction vector (convert to vector of length 1)
			dir.normalize();
			console.log("Init", {X,Y,Z})

			let [startProbState0, startProbState1] = compute_probs(X, Y, Z);
			finalProbState0 = startProbState0;
			finalProbState1 = startProbState1;
			display_probs(startProbState0, startProbState1)

			let origin = new THREE.Vector3( 0, 0, 0 );
			let length = sphereRadius;
			let hex = 0xffff00;

			arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
			scene.add( arrowHelper );

			//Axes
			const axis = new THREE.AxesHelper(sphereRadius);
			scene.add(axis); 

			// Images

			const labels = [
				pos = createLabel('../images/pos.png', new THREE.Vector3(sphereRadius+0.5, 0, 0)),
				neg = createLabel('../images/neg.png', new THREE.Vector3(-sphereRadius-0.5, 0, 0)),
				pos_i = createLabel('../images/pos_i.png', new THREE.Vector3(0, 0, -sphereRadius-0.5)),
				neg_i = createLabel('../images/neg_i.png', new THREE.Vector3(0, 0, +sphereRadius+0.5)),
				state0 = createLabel('../images/state0.png', new THREE.Vector3(0, sphereRadius+0.5, 0)),
				state1 = createLabel('../images/state1.png', new THREE.Vector3(0, -sphereRadius-0.7, 0))
			];
			labels.forEach(label => sphereGroup.add(label));

			pos.scale.set(0.6, 0.5, 0.5); 
			neg.scale.set(0.6, 0.5, 0.5); 
			pos_i.scale.set(0.7, 0.5, 0.5); 
			neg_i.scale.set(0.7, 0.5, 0.5);
			state0.scale.set(0.5, 0.5, 0.5);
			state1.scale.set(0.5, 0.5, 0.5);

			// Basic ambient lighting.
			scene.add(new THREE.AmbientLight(0x000fff));
			// TASK: add more complex lighting for 'face' rendering mode (requirement 2).

			// Set up the Web GL renderer.
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			// Handle resizing of the browser window.
			window.addEventListener('resize', handleResize, false);

		}

		// Handle resizing of the browser window.
		function handleResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		// Animation loop function. This function is called whenever an update is required.
		function animate() {
			requestAnimationFrame(animate);
			
			camera.position.x = distFromOrigin * Math.cos(cameraAngle);
			camera.position.z = distFromOrigin * Math.sin(cameraAngle);
			camera.lookAt(0,0,0);
 
			cameraAngle += 0.005;
			
			if (finalAngle) {
				document.removeEventListener('keydown', handleKeyDown);
				const step = 0.02;
				const remaining = finalAngle - rotatedAngle;

				if (remaining > 0) {
					
					const angleStep = Math.min(step, remaining);
					stepQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angleStep);
					arrowHelper.applyQuaternion(stepQuat);
					rotatedAngle += angleStep;
			
					const progress = rotatedAngle / finalAngle;
					const currentProb0 = startProbState0 + (finalProbState0 - startProbState0) * progress;
					const currentProb1 = startProbState1 + (finalProbState1 - startProbState1) * progress;
					display_probs(currentProb0, currentProb1);
				} else {
				// Rotation complete, stop rotating
				stepQuat = null;
				rotationAxis = null;
				rotatedAngle = 0;
				finalAngle = 0;
				document.addEventListener('keydown', handleKeyDown);
				}
			}
			

			renderer.render(scene, camera);
		}

		// Handle keyboard presses.
		function handleKeyDown(event) {
			let start_coords = new THREE.Vector3(X,Z,Y);
			switch(event.key.toLowerCase()) {

				case 'x':
				rotationAxis = new THREE.Vector3(1, 0, 0);
				finalAngle = Math.PI;

				const rX = new THREE.Matrix3();
				rX.set(1,0,0,0,-1,0,0,0,-1)

				start_coords.applyMatrix3(rX);

				X = start_coords.x;
				Y = start_coords.z;
				Z = start_coords.y;

				break;

				case 'y':
				rotationAxis = new THREE.Vector3(0, 0, 1);
				finalAngle = Math.PI;

				const rY = new THREE.Matrix3();
				rY.set(-1,0,0,0,1,0,0,0,-1)

				start_coords.applyMatrix3(rY);

				X = start_coords.x;
				Y = start_coords.z;
				Z = start_coords.y;

				break;

				case 'z':	
				rotationAxis = new THREE.Vector3(0, 1, 0);
				finalAngle = Math.PI;

				const rZ = new THREE.Matrix3();
				rZ.set(-1,0,0,0,-1,0,0,0,1)

				start_coords.applyMatrix3(rZ);

				X = start_coords.x;
				Y = start_coords.z;
				Z = start_coords.y;

				break;

				case 'h':
				rotationAxis = new THREE.Vector3(1/Math.sqrt(2), 1/Math.sqrt(2), 0);
				finalAngle = Math.PI;

				const rHAD = new THREE.Matrix3();
				rHAD.set(0,0,1,0,-1,0,1,0,0)

				start_coords.applyMatrix3(rHAD);

				X = start_coords.x;
				Y = start_coords.z;
				Z = start_coords.y;

				break;

				case 'o':

				X = 0;
				Y = 1;
				Z = 0;

				const resetVec = new THREE.Vector3(X, Y, Z);
				arrowHelper.setDirection(resetVec.clone().normalize());
				
				break;
				
				case 'r':

				do {
					X = Math.random() * 2 - 1;
					Y = Math.random() * 2 - 1;
					Z = Math.random() * 2 - 1;
				} while (X === 0 && Y === 0 && Z === 0);

				const randomVec = new THREE.Vector3(X, Y, Z);
				arrowHelper.setDirection(randomVec.clone().normalize());
				
				break;
			}
			startProbState0 = finalProbState0;
			startProbState1 = finalProbState1;
			[finalProbState0, finalProbState1] = compute_probs(X, Y, Z);

			console.log("Start", startProbState0, startProbState1);
			console.log("End", finalProbState0, finalProbState1);
			display_probs(finalProbState0, finalProbState1);
		}

		function compute_probs(X,Y,Z) {
			console.log("Func",{X,Y,Z})
			let polar = Math.acos(Y);
			let azimuth = Math.atan2(Z,X);

			console.log(polar, azimuth)

			let probState0 = Math.pow(Math.cos(polar / 2), 2);
			let probState1 = Math.pow(Math.sin(polar / 2), 2);

			console.log(probState0, probState1)
			return [probState0, probState1]		
		}

		function display_probs(numberA, numberB) {
			document.getElementById('state0').textContent = numberA.toFixed(2);
			document.getElementById('state1').textContent = numberB.toFixed(2);
		}

		function createLabel(texturePath, position) {
			const texture = new THREE.TextureLoader().load(texturePath);
			const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
			const sprite = new THREE.Sprite(material);
			sprite.position.copy(position);
			return sprite;
		}

		function cleanNumber(n, epsilon = 1e-10) {
			return Math.abs(n) < epsilon ? 0 : n;
		}

	</script>
</body>

</html>